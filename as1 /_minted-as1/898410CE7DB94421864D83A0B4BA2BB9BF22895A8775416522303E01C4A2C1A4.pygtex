\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{k}{def} \PYGdefault{n+nf}{batch\PYGdefaultZus{}grad\PYGdefaultZus{}descent}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{alpha}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{0.1}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{1000}\PYGdefault{p}{,} \PYGdefault{n}{check\PYGdefaultZus{}gradient}\PYGdefault{o}{=}\PYGdefault{n+nb+bp}{False}\PYGdefault{p}{):}
	\PYGdefault{l+s+sd}{\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
\PYGdefault{l+s+sd}{	In this question you will implement batch gradient descent to}
\PYGdefault{l+s+sd}{	minimize the square loss objective}

\PYGdefault{l+s+sd}{	Args:}
\PYGdefault{l+s+sd}{	X \PYGdefaultZhy{} the feature vector, 2D numpy array of size (num\PYGdefaultZus{}instances, num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{	y \PYGdefaultZhy{} the label vector, 1D numpy array of size (num\PYGdefaultZus{}instances)}
\PYGdefault{l+s+sd}{	alpha \PYGdefaultZhy{} step size in gradient descent}
\PYGdefault{l+s+sd}{	num\PYGdefaultZus{}iter \PYGdefaultZhy{} number of iterations to run}
\PYGdefault{l+s+sd}{	check\PYGdefaultZus{}gradient \PYGdefaultZhy{} a boolean value indicating whether checking the}
\PYGdefault{l+s+sd}{	gradient when updating}

\PYGdefault{l+s+sd}{	Returns:}
\PYGdefault{l+s+sd}{	theta\PYGdefaultZus{}hist \PYGdefaultZhy{} store the the history of parameter vector in iteration,}
\PYGdefault{l+s+sd}{	2D numpy array of size (num\PYGdefaultZus{}iter+1, num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{	for instance, theta in iteration 0 should be theta\PYGdefaultZus{}hist[0],}
\PYGdefault{l+s+sd}{	 theta in ieration (num\PYGdefaultZus{}iter) is theta\PYGdefaultZus{}hist[\PYGdefaultZhy{}1]}
\PYGdefault{l+s+sd}{	loss\PYGdefaultZus{}hist \PYGdefaultZhy{} the history of objective function vector,}
\PYGdefault{l+s+sd}{	1D numpy array of size (num\PYGdefaultZus{}iter+1)}
\PYGdefault{l+s+sd}{	\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
    \PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}features} \PYGdefault{o}{=} \PYGdefault{n}{X}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],} \PYGdefault{n}{X}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]}
    \PYGdefault{n}{theta\PYGdefaultZus{}hist} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{((}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{))}  \PYGdefault{c}{\PYGdefaultZsh{}Initialize theta\PYGdefaultZus{}hist}
    \PYGdefault{n}{loss\PYGdefaultZus{}hist} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}initialize loss\PYGdefaultZus{}hist}
    \PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{ones}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}initialize theta}

    \PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,:]} \PYGdefault{o}{=} \PYGdefault{n}{theta}
    \PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}

    \PYGdefault{k}{if} \PYGdefault{o+ow}{not} \PYGdefault{n}{check\PYGdefaultZus{}gradient}\PYGdefault{p}{:}
	    \PYGdefault{k}{for} \PYGdefault{n}{i} \PYGdefault{o+ow}{in} \PYGdefault{n+nb}{list}\PYGdefault{p}{(}\PYGdefault{n+nb}{xrange}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)):}
		    \PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{theta} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss\PYGdefaultZus{}gradient}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{*}\PYGdefault{n}{alpha}
		    \PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{,:]} \PYGdefault{o}{=} \PYGdefault{n}{theta}
		    \PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}
    \PYGdefault{k}{else}\PYGdefault{p}{:}
	    \PYGdefault{k}{for} \PYGdefault{n}{i} \PYGdefault{o+ow}{in} \PYGdefault{n+nb}{list}\PYGdefault{p}{(}\PYGdefault{n+nb}{xrange}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)):}
		    \PYGdefault{k}{if} \PYGdefault{n}{grad\PYGdefaultZus{}checker}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{,}\PYGdefault{n}{epsilon}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{0.01}\PYGdefault{p}{,} \PYGdefault{n}{tolerance}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{1e\PYGdefaultZhy{}4}\PYGdefault{p}{):}
			    \PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{theta} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss\PYGdefaultZus{}gradient}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{*}\PYGdefault{n}{alpha}
			    \PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{,:]} \PYGdefault{o}{=} \PYGdefault{n}{theta}
			    \PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}
		    \PYGdefault{k}{else}\PYGdefault{p}{:}
			    \PYGdefault{k}{print}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZsq{}error, please check gradient function\PYGdefaultZsq{}}\PYGdefault{p}{)}
			    \PYGdefault{k}{return}
    \PYGdefault{k}{return} \PYGdefault{p}{(}\PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{,}\PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{)}
\end{Verbatim}
