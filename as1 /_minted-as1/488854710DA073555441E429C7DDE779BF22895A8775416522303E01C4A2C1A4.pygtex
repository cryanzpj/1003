\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{k}{def} \PYGdefault{n+nf}{stochastic\PYGdefaultZus{}grad\PYGdefaultZus{}descent}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{alpha}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{0.1}\PYGdefault{p}{,} \PYGdefault{n}{lambda\PYGdefaultZus{}reg}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{1000}\PYGdefault{p}{):}
\PYGdefault{l+s+sd}{\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
\PYGdefault{l+s+sd}{In this question you will implement stochastic gradient descent with a regularization term}

\PYGdefault{l+s+sd}{Args:}
\PYGdefault{l+s+sd}{X \PYGdefaultZhy{} the feature vector, 2D numpy array of size (num\PYGdefaultZus{}instances, num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{y \PYGdefaultZhy{} the label vector, 1D numpy array of size (num\PYGdefaultZus{}instances)}
\PYGdefault{l+s+sd}{alpha \PYGdefaultZhy{} string or float. step size in gradient descent}

\PYGdefault{l+s+sd}{if alpha is a float, then the step size in every iteration is alpha.}
\PYGdefault{l+s+sd}{if alpha == \PYGdefaultZdq{}1/sqrt(t)\PYGdefaultZdq{}, alpha = 1/sqrt(t)}
\PYGdefault{l+s+sd}{if alpha == \PYGdefaultZdq{}1/t\PYGdefaultZdq{}, alpha = 1/t}
\PYGdefault{l+s+sd}{lambda\PYGdefaultZus{}reg \PYGdefaultZhy{} the regularization coefficient}
\PYGdefault{l+s+sd}{num\PYGdefaultZus{}iter \PYGdefaultZhy{} number of epochs (i.e number of times) to go through the whole training set}

\PYGdefault{l+s+sd}{Returns:}
\PYGdefault{l+s+sd}{theta\PYGdefaultZus{}hist \PYGdefaultZhy{} the history of parameter vector,}
\PYGdefault{l+s+sd}{3D numpy array of size (num\PYGdefaultZus{}iter, num\PYGdefaultZus{}instances, num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{loss hist \PYGdefaultZhy{} the history of regularized loss function vector,}
\PYGdefault{l+s+sd}{2D numpy array of size(num\PYGdefaultZus{}iter, num\PYGdefaultZus{}instances)}
\PYGdefault{l+s+sd}{\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
\PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}features} \PYGdefault{o}{=} \PYGdefault{n}{X}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],} \PYGdefault{n}{X}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]}
\PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{ones}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}Initialize theta}

\PYGdefault{n}{theta\PYGdefaultZus{}hist} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{((}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{))}  \PYGdefault{c}{\PYGdefaultZsh{}Initialize theta\PYGdefaultZus{}hist}
\PYGdefault{n}{loss\PYGdefaultZus{}hist} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{((}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{p}{,} \PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{))} \PYGdefault{c}{\PYGdefaultZsh{}Initialize loss\PYGdefaultZus{}hist}
\PYGdefault{n}{t} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}

\PYGdefault{k}{for} \PYGdefault{n}{n} \PYGdefault{o+ow}{in} \PYGdefault{n+nb}{list}\PYGdefault{p}{(}\PYGdefault{n+nb}{xrange}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}iter}\PYGdefault{p}{)):}
\PYGdefault{n}{generator} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{random}\PYGdefault{o}{.}\PYGdefault{n}{permutation}\PYGdefault{p}{(}\PYGdefault{n+nb}{list}\PYGdefault{p}{(}\PYGdefault{n+nb}{xrange}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{)))} \PYGdefault{c}{\PYGdefaultZsh{} define ramdom sampling sequence}

\PYGdefault{k}{for} \PYGdefault{n}{i} \PYGdefault{o+ow}{in} \PYGdefault{n+nb}{list}\PYGdefault{p}{(}\PYGdefault{n+nb}{xrange}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}\PYGdefault{n}{num\PYGdefaultZus{}instances}\PYGdefault{p}{)):}
	\PYGdefault{n}{t}\PYGdefault{o}{+=}\PYGdefault{l+m+mf}{1.0}
	\PYGdefault{n}{num} \PYGdefault{o}{=} \PYGdefault{n}{generator}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]}
	\PYGdefault{k}{if} \PYGdefault{n}{alpha} \PYGdefault{o}{==} \PYGdefault{l+s}{\PYGdefaultZdq{}1/sqrt(t)\PYGdefaultZdq{}}\PYGdefault{p}{:}
		\PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{theta} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{o}{/}\PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{sqrt}\PYGdefault{p}{(}\PYGdefault{n}{t}\PYGdefault{p}{)} \PYGdefault{o}{*}\PYGdefault{p}{(} \PYGdefault{p}{(}\PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{inner}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:],} \PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{n}{y}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{])}
			\PYGdefault{o}{*}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:]} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{2}\PYGdefault{o}{*}\PYGdefault{n}{lambda\PYGdefaultZus{}reg}\PYGdefault{o}{*}\PYGdefault{n}{theta}\PYGdefault{p}{)}
	\PYGdefault{k}{elif} \PYGdefault{n}{alpha}  \PYGdefault{o}{==} \PYGdefault{l+s}{\PYGdefaultZdq{}1/t\PYGdefaultZdq{}}\PYGdefault{p}{:}
		\PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{theta} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{p}{(}\PYGdefault{l+m+mi}{1}\PYGdefault{o}{/}\PYGdefault{p}{(}\PYGdefault{n}{t}\PYGdefault{p}{))} \PYGdefault{o}{*} \PYGdefault{p}{(} \PYGdefault{p}{(}\PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{inner}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:],} \PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{n}{y}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{])}
			\PYGdefault{o}{*}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:]} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{2}\PYGdefault{o}{*}\PYGdefault{n}{lambda\PYGdefaultZus{}reg}\PYGdefault{o}{*}\PYGdefault{n}{theta}\PYGdefault{p}{)}
	\PYGdefault{k}{else}\PYGdefault{p}{:}
		\PYGdefault{n}{theta} \PYGdefault{o}{=} \PYGdefault{n}{theta} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{alpha} \PYGdefault{o}{*} \PYGdefault{p}{((}\PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{inner}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:],} \PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{n}{y}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{])}
			\PYGdefault{o}{*}\PYGdefault{n}{X}\PYGdefault{p}{[}\PYGdefault{n}{num}\PYGdefault{p}{,:]} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{2}\PYGdefault{o}{*}\PYGdefault{n}{lambda\PYGdefaultZus{}reg}\PYGdefault{o}{*}\PYGdefault{n}{theta}\PYGdefault{p}{)}

	\PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{n}\PYGdefault{p}{][}\PYGdefault{n}{i}\PYGdefault{p}{,:]} \PYGdefault{o}{=} \PYGdefault{n}{theta}
	\PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{[}\PYGdefault{n}{n}\PYGdefault{p}{,}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{+}\PYGdefault{n}{lambda\PYGdefaultZus{}reg}\PYGdefault{o}{*}\PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{linalg}\PYGdefault{o}{.}\PYGdefault{n}{norm}\PYGdefault{p}{(}\PYGdefault{n}{theta}\PYGdefault{p}{)}\PYGdefault{o}{**}\PYGdefault{l+m+mi}{2}

\PYGdefault{k}{return} \PYGdefault{p}{(}\PYGdefault{n}{theta\PYGdefaultZus{}hist}\PYGdefault{p}{,}\PYGdefault{n}{loss\PYGdefaultZus{}hist}\PYGdefault{p}{)}
\end{Verbatim}
