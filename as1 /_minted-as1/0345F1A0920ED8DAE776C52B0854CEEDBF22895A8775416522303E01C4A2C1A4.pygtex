\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{k}{def} \PYGdefault{n+nf}{grad\PYGdefaultZus{}checker}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{theta}\PYGdefault{p}{,} \PYGdefault{n}{epsilon}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{0.01}\PYGdefault{p}{,} \PYGdefault{n}{tolerance}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{1e\PYGdefaultZhy{}4}\PYGdefault{p}{):}
	\PYGdefault{l+s+sd}{\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}Implement Gradient Checker}
\PYGdefault{l+s+sd}{	Check that the function compute\PYGdefaultZus{}square\PYGdefaultZus{}loss\PYGdefaultZus{}gradient returns the}
\PYGdefault{l+s+sd}{	correct gradient for the given X, y, and theta.}

\PYGdefault{l+s+sd}{	Args:}
\PYGdefault{l+s+sd}{	X \PYGdefaultZhy{} the feature vector, 2D numpy array of size (num\PYGdefaultZus{}instances, num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{	y \PYGdefaultZhy{} the label vector, 1D numpy array of size (num\PYGdefaultZus{}instances)}
\PYGdefault{l+s+sd}{	theta \PYGdefaultZhy{} the parameter vector, 1D numpy array of size (num\PYGdefaultZus{}features)}
\PYGdefault{l+s+sd}{	epsilon \PYGdefaultZhy{} the epsilon used in approximation}
\PYGdefault{l+s+sd}{	tolerance \PYGdefaultZhy{} the tolerance error}

\PYGdefault{l+s+sd}{	Return:}
\PYGdefault{l+s+sd}{	A boolean value indicate whether the gradient is correct or not}

\PYGdefault{l+s+sd}{	\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
	\PYGdefault{n}{true\PYGdefaultZus{}gradient} \PYGdefault{o}{=} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss\PYGdefaultZus{}gradient}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{theta}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}the true gradient}
	\PYGdefault{n}{num\PYGdefaultZus{}features} \PYGdefault{o}{=} \PYGdefault{n}{theta}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]}
	\PYGdefault{n}{approx\PYGdefaultZus{}grad} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}Initialize the gradient we approximate}

	\PYGdefault{n}{y} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{array}\PYGdefault{p}{([}\PYGdefault{n}{y}\PYGdefault{p}{])}\PYGdefault{o}{.}\PYGdefault{n}{T}
	\PYGdefault{n}{approx\PYGdefaultZus{}matrix} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{identity}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}initialize the directional derivatives}
	\PYGdefault{n}{approx\PYGdefaultZus{}grad} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{apply\PYGdefaultZus{}along\PYGdefaultZus{}axis}\PYGdefault{p}{(}\PYGdefault{k}{lambda} \PYGdefault{n}{t}\PYGdefault{p}{:(}\PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{o}{+} \PYGdefault{n}{epsilon}\PYGdefault{o}{*}\PYGdefault{n}{t}\PYGdefault{p}{)}
	\PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{compute\PYGdefaultZus{}square\PYGdefaultZus{}loss}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{epsilon}\PYGdefault{o}{*}\PYGdefault{n}{t}\PYGdefault{p}{))}\PYGdefault{o}{/}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{2}\PYGdefault{o}{*}\PYGdefault{n}{epsilon}\PYGdefault{p}{)} \PYGdefault{p}{,}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}\PYGdefault{n}{approx\PYGdefaultZus{}matrix}\PYGdefault{p}{)}
	\PYGdefault{c}{\PYGdefaultZsh{}apply the gradient function to directional derivatives}

	\PYGdefault{n}{checker} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{linalg}\PYGdefault{o}{.}\PYGdefault{n}{norm}\PYGdefault{p}{(}\PYGdefault{n}{true\PYGdefaultZus{}gradient} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{approx\PYGdefaultZus{}grad}\PYGdefault{p}{)}

	\PYGdefault{k}{return} \PYGdefault{n}{checker} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{tolerance}
\end{Verbatim}
