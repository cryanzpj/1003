\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{k}{def} \PYGdefault{n+nf}{generic\PYGdefaultZus{}gradient\PYGdefaultZus{}checker}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{theta}\PYGdefault{p}{,} \PYGdefault{n}{objective\PYGdefaultZus{}func}\PYGdefault{p}{,}
\PYGdefault{n}{gradient\PYGdefaultZus{}func}\PYGdefault{p}{,} \PYGdefault{n}{epsilon}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{0.01}\PYGdefault{p}{,} \PYGdefault{n}{tolerance}\PYGdefault{o}{=}\PYGdefault{l+m+mf}{1e\PYGdefaultZhy{}4}\PYGdefault{p}{):}
	\PYGdefault{l+s+sd}{\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
\PYGdefault{l+s+sd}{	The functions takes objective\PYGdefaultZus{}func and gradient\PYGdefaultZus{}func as parameters.}
\PYGdefault{l+s+sd}{	And check whether gradient\PYGdefaultZus{}func(X, y, theta) returned}
\PYGdefault{l+s+sd}{	the true gradient for objective\PYGdefaultZus{}func(X, y, theta).}
\PYGdefault{l+s+sd}{	Eg: In LSR, the objective\PYGdefaultZus{}func = compute\PYGdefaultZus{}square\PYGdefaultZus{}loss,}
\PYGdefault{l+s+sd}{	and gradient\PYGdefaultZus{}func = compute\PYGdefaultZus{}square\PYGdefaultZus{}loss\PYGdefaultZus{}gradient}
\PYGdefault{l+s+sd}{	\PYGdefaultZdq{}\PYGdefaultZdq{}\PYGdefaultZdq{}}
	\PYGdefault{n}{true\PYGdefaultZus{}gradient} \PYGdefault{o}{=} \PYGdefault{n}{gradient\PYGdefaultZus{}func}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,} \PYGdefault{n}{y}\PYGdefault{p}{,} \PYGdefault{n}{theta}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}the true gradient}
	\PYGdefault{n}{num\PYGdefaultZus{}features} \PYGdefault{o}{=} \PYGdefault{n}{theta}\PYGdefault{o}{.}\PYGdefault{n}{shape}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]}
	\PYGdefault{n}{approx\PYGdefaultZus{}grad} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{zeros}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)} \PYGdefault{c}{\PYGdefaultZsh{}Initialize the gradient we approximate}

	\PYGdefault{n}{y} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{array}\PYGdefault{p}{([}\PYGdefault{n}{y}\PYGdefault{p}{])}\PYGdefault{o}{.}\PYGdefault{n}{T}
	\PYGdefault{n}{approx\PYGdefaultZus{}matrix} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{identity}\PYGdefault{p}{(}\PYGdefault{n}{num\PYGdefaultZus{}features}\PYGdefault{p}{)}
	\PYGdefault{n}{approx\PYGdefaultZus{}grad} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{apply\PYGdefaultZus{}along\PYGdefaultZus{}axis}\PYGdefault{p}{(}\PYGdefault{k}{lambda} \PYGdefault{n}{t}\PYGdefault{p}{:} \PYGdefault{p}{(}\PYGdefault{n}{objective\PYGdefaultZus{}func}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{o}{+} \PYGdefault{n}{epsilon}\PYGdefault{o}{*}\PYGdefault{n}{t}\PYGdefault{p}{)}
	\PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{objective\PYGdefaultZus{}func}\PYGdefault{p}{(}\PYGdefault{n}{X}\PYGdefault{p}{,}\PYGdefault{n}{y}\PYGdefault{p}{,}\PYGdefault{n}{theta}\PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{epsilon}\PYGdefault{o}{*}\PYGdefault{n}{t}\PYGdefault{p}{))}\PYGdefault{o}{/}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{2}\PYGdefault{o}{*}\PYGdefault{n}{epsilon}\PYGdefault{p}{)} \PYGdefault{p}{,}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}\PYGdefault{n}{approx\PYGdefaultZus{}matrix}\PYGdefault{p}{)}

	\PYGdefault{n}{checker} \PYGdefault{o}{=} \PYGdefault{n}{np}\PYGdefault{o}{.}\PYGdefault{n}{linalg}\PYGdefault{o}{.}\PYGdefault{n}{norm}\PYGdefault{p}{(}\PYGdefault{n}{true\PYGdefaultZus{}gradient} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{approx\PYGdefaultZus{}grad}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{n}{checker} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{tolerance}
\end{Verbatim}
